// Generated by CoffeeScript 1.6.3
/*
  glider 0.1.1 - AngularJS slider
  https://github.com/evrone/glider
  Copyright (c) 2013 Valentin Vasilyev, Dmitry Karpunin
  Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.

  examples:

  basic:
  <slider min="0" max="100" step="1" value="age"></slider>

  update only on mouse up
  <slider defer_update min="0" max="100" step="1" value="age"></slider>

  slider with increments (incompatible with step option)
  <slider min="0" max="100" increments="10,50,60,90"></slider>
*/


(function() {
  'use strict';
  var app;

  app = angular.module("glider", []);

  app.directive('slider', [
    '$document', function($document) {
      var getSubElement, moveHandle;
      getSubElement = function(sliderElement, className) {
        return sliderElement[0].getElementsByClassName(className)[0];
      };
      moveHandle = function(elem, posX) {
        angular.element(getSubElement(elem, 'handle')).css('left', "" + posX + "%");
        return angular.element(getSubElement(elem, 'range')).css('width', "" + posX + "%");
      };
      return {
        template: "<span class=\"g-slider horizontal\">\n  <span class=\"slider\">\n    <span class=\"range\"></span>\n    <span class=\"handle\" ng-mousedown=\"mouseDown($event)\"></span>\n  </span>\n  <span class=\"side dec\">\n    <span class=\"button\" ng-click=\"step(-1)\">-</span>\n    <span class=\"bound-value\">{{min() | intersperse}}</span>\n  </span>\n  <span class=\"side inc\">\n    <span class=\"button\" ng-click=\"step(+1)\">+</span>\n    <span class=\"bound-value\">{{max() | intersperse}}</span>\n  </span>\n  <span class=\"increments\">\n    <span ng-repeat=\"i in increments\" class=\"i\" style=\"left: {{i.offset}}%\">\n      {{ i.value | intersperse }}\n    </span>\n  </span>\n</span>",
        replace: true,
        restrict: "E",
        scope: {
          value: "=",
          min: "&",
          max: "&"
        },
        link: function(scope, element, attrs) {
          var createSnapValues, deferUpdate, dragging, parseIncrements, refreshHandle, sliderElement, step, xPosition;
          parseIncrements = function() {
            var i, increments, max, min, offset, trim;
            trim = function(input) {
              if (input) {
                return input.replace(/^\s+|\s+$/g, '');
              } else {
                return input;
              }
            };
            offset = function(min, max, value) {
              return value / Math.abs(max - min) * 100;
            };
            if (attrs.increments) {
              min = scope.min();
              max = scope.max();
              increments = attrs.increments.split(',');
              return increments = (function() {
                var _i, _len, _ref, _results;
                _results = [];
                for (_i = 0, _len = increments.length; _i < _len; _i++) {
                  i = increments[_i];
                  if ((min < (_ref = parseInt(i)) && _ref < max)) {
                    _results.push({
                      value: parseInt(trim(i), 10),
                      offset: offset(min, max, i)
                    });
                  }
                }
                return _results;
              })();
            }
          };
          createSnapValues = function(increments) {
            var i;
            if (attrs.increments != null) {
              return ([scope.min(), scope.max()].concat((function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = increments.length; _i < _len; _i++) {
                  i = increments[_i];
                  _results.push(i.value);
                }
                return _results;
              })())).sort(function(a, b) {
                return a - b;
              });
            }
          };
          sliderElement = getSubElement(element, 'slider');
          dragging = false;
          xPosition = 0;
          step = attrs.step != null ? parseInt(attrs.step, 10) : 1;
          deferUpdate = attrs.deferUpdate != null;
          if (scope.value == null) {
            scope.value = scope.min();
          }
          scope.increments = parseIncrements(attrs.increments);
          scope.snapValues = createSnapValues(scope.increments);
          refreshHandle = function() {
            var range;
            range = scope.max() - scope.min();
            if (range === 0) {
              xPosition = 0;
            } else {
              xPosition = (scope.value - scope.min()) / range * 100;
              xPosition = Math.min(Math.max(0, xPosition), 100);
            }
            return moveHandle(element, xPosition);
          };
          scope.$watch('min()', function(minValue) {
            if (scope.value < minValue) {
              return scope.value = minValue;
            } else {
              return refreshHandle();
            }
          });
          scope.$watch('max()', function(maxValue) {
            if (scope.value > maxValue) {
              return scope.value = maxValue;
            } else {
              return refreshHandle();
            }
          });
          scope.$watch('value', function(newVal, oldVal) {
            if (dragging) {
              return;
            }
            if ((scope.min() <= newVal && newVal <= scope.max())) {
              return refreshHandle();
            } else {
              return newVal = oldVal;
            }
          });
          scope.step = function(steps) {
            var doIncrement, doStep;
            doStep = function(steps) {
              var newValue;
              newValue = scope.value + steps * step;
              if ((scope.min() <= newValue && newValue <= scope.max())) {
                return scope.value = newValue;
              }
            };
            doIncrement = function(steps) {
              var newVal, sv;
              newVal = steps > 0 ? ((function() {
                var _i, _len, _ref, _results;
                _ref = scope.snapValues;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  sv = _ref[_i];
                  if (sv > scope.value) {
                    _results.push(sv);
                  }
                }
                return _results;
              })())[0] : ((function() {
                var _i, _len, _ref, _results;
                _ref = scope.snapValues;
                _results = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  sv = _ref[_i];
                  if (sv < scope.value) {
                    _results.push(sv);
                  }
                }
                return _results;
              })()).sort(function(a, b) {
                return b - a;
              })[0];
              if (newVal != null) {
                return scope.value = newVal;
              }
            };
            if (attrs.increments != null) {
              return doIncrement(steps);
            } else {
              return doStep(steps);
            }
          };
          return scope.mouseDown = function($event) {
            var snap, startPointX, updateValue;
            dragging = true;
            startPointX = $event.pageX;
            updateValue = function() {
              scope.value = Math.round((((scope.max() - scope.min()) * (xPosition / 100)) + scope.min()) / step) * step;
              return scope.$apply();
            };
            snap = function() {
              var closest, diff, i, l, min;
              i = 0;
              l = scope.snapValues.length;
              while (i < l) {
                diff = Math.abs(scope.snapValues[i] - scope.value);
                if (typeof min === "undefined" || min === null) {
                  min = diff;
                }
                if (diff <= min) {
                  closest = scope.snapValues[i];
                  min = diff;
                }
                i++;
              }
              scope.value = closest;
              return scope.$apply();
            };
            $document.on('mousemove', function($event) {
              var moveDelta;
              if (!dragging) {
                return;
              }
              moveDelta = $event.pageX - startPointX;
              xPosition += moveDelta / sliderElement.offsetWidth * 100;
              if (xPosition < 0) {
                xPosition = 0;
              } else if (xPosition > 100) {
                xPosition = 100;
              } else {
                startPointX = $event.pageX;
              }
              if (!deferUpdate) {
                updateValue();
              }
              return moveHandle(element, xPosition);
            });
            return $document.on('mouseup', function() {
              dragging = false;
              if (deferUpdate) {
                updateValue();
              }
              if (scope.increments) {
                snap();
              }
              return $document.off('mousemove');
            });
          };
        }
      };
    }
  ]);

  app.filter('intersperse', function() {
    return function(input) {
      var reverse, reversed, reversed_and_sliced, sliced;
      if (input == null) {
        return;
      }
      input = input.toString();
      reverse = function(input) {
        return input.split('').reverse().join('');
      };
      reversed = reverse(input);
      reversed_and_sliced = reversed.replace(/(.{3})/g, '$1 ');
      sliced = reverse(reversed_and_sliced);
      return sliced.trim();
    };
  });

}).call(this);
